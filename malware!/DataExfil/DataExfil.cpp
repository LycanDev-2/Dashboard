#include <iostream>
#include <fstream>
#include <string>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <thread>
#include <curl/curl.h>

namespace fs = std::filesystem;

/* ========================
    CONFIGURATION SECTION
   ======================== */

// ðŸ”§ Change this to your actual upload endpoint
const std::string UPLOAD_URL = "https://example.com/upload";

// How many times to retry a failed upload
const int MAX_RETRIES = 3;

// How many seconds to wait between retries
const int RETRY_DELAY_SECONDS = 2;

// Log file name
const std::string LOG_FILENAME = "log.txt";

/* ========================
    END CONFIGURATION
   ======================== */

// Format current time as "YYYY-MM-DD HH:MM:SS"
std::string timestamp() {
    auto now = std::chrono::system_clock::now();
    auto time_t_now = std::chrono::system_clock::to_time_t(now);
    std::tm tm_now;
#if defined(_WIN32) || defined(_WIN64)
    localtime_s(&tm_now, &time_t_now);
#else
    localtime_r(&time_t_now, &tm_now);
#endif
    std::ostringstream oss;
    oss << std::put_time(&tm_now, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

// Convert raw byte count into a human-readable string
std::string human_size(std::uintmax_t bytes) {
    const char* units[] = {"B", "KB", "MB", "GB", "TB"};
    double size = static_cast<double>(bytes);
    int unitIndex = 0;

    while (size >= 1024.0 && unitIndex < 4) {
        size /= 1024.0;
        ++unitIndex;
    }

    std::ostringstream oss;
    oss << std::fixed << std::setprecision(2) << size << " " << units[unitIndex];
    return oss.str();
}

struct Stats {
    int total = 0;
    int ok = 0;
    int fail = 0;
};

bool try_upload(const std::string& file_path, std::string& error_message, bool dry_run) {
    if (dry_run) {
        return true; // Pretend success in dry-run mode
    }

    CURL *curl;
    CURLcode res;
    bool success = false;

    curl = curl_easy_init();
    if (curl) {
        curl_mime *form = nullptr;
        curl_mimepart *field = nullptr;

        form = curl_mime_init(curl);

        // File field
        field = curl_mime_addpart(form);
        curl_mime_name(field, "file");
        curl_mime_filedata(field, file_path.c_str());

        // Target URL
        curl_easy_setopt(curl, CURLOPT_URL, UPLOAD_URL.c_str());
        curl_easy_setopt(curl, CURLOPT_MIMEPOST, form);

        // Perform upload
        res = curl_easy_perform(curl);
        if (res == CURLE_OK) {
            success = true;
        } else {
            error_message = curl_easy_strerror(res);
        }

        curl_mime_free(form);
        curl_easy_cleanup(curl);
    }
    return success;
}

bool upload_file(const std::string& file_path, std::ofstream& log, Stats* stats, bool dry_run) {
    // Get file size
    std::uintmax_t size = 0;
    try {
        size = fs::file_size(file_path);
    } catch (...) {
        size = 0;
    }
    std::string size_str = human_size(size);

    if (stats) stats->total++;

    if (dry_run) {
        if (stats) stats->ok++;
        log << "[" << timestamp() << "] [SKIP] "
            << file_path << " (" << size_str << ") (dry-run)\n";
        std::cout << "[" << timestamp() << "] [SKIP] "
        << file_path << " (" << size_str << ") (dry-run)\n";
        return true;
    }

    std::string error_message;
    for (int attempt = 1; attempt <= MAX_RETRIES; ++attempt) {
        if (try_upload(file_path, error_message, dry_run)) {
            if (stats) stats->ok++;
            log << "[" << timestamp() << "] [OK]   "
                << file_path << " (" << size_str << ")"
                << " [attempt " << attempt << "]\n";
            std::cout << "[" << timestamp() << "] [OK]   "
            << file_path << " (" << size_str << ")"
            << " [attempt " << attempt << "]\n";
            return true;
        } else {
            std::cerr << "[" << timestamp() << "] [RETRY "
            << attempt << "] " << file_path
            << " (" << size_str << ") -> " << error_message << "\n";
            if (attempt < MAX_RETRIES) {
                std::this_thread::sleep_for(std::chrono::seconds(RETRY_DELAY_SECONDS));
            }
        }
    }

    if (stats) stats->fail++;
    log << "[" << timestamp() << "] [FAIL] "
        << file_path << " (" << size_str << ")"
        << " after " << MAX_RETRIES << " attempts -> " << error_message << "\n";
    std::cerr << "[" << timestamp() << "] [FAIL] "
    << file_path << " (" << size_str << ")"
    << " after " << MAX_RETRIES << " attempts -> " << error_message << "\n";
    return false;
}

int main(int argc, char* argv[]) {
    bool dry_run = false;
    if (argc > 1 && std::string(argv[1]) == "--dry-run") {
        dry_run = true;
        std::cout << "âš  Running in DRY-RUN mode â€” no files will actually be uploaded.\n";
    }

    // Open log file
    std::ofstream log(LOG_FILENAME, std::ios::out);
    if (!log) {
        std::cerr << "Failed to open " << LOG_FILENAME << " for writing.\n";
        return 1;
    }

    if (!dry_run) {
        curl_global_init(CURL_GLOBAL_DEFAULT);
    }

    log << "=== File Upload Log ===\n";
    log << "Target URL: " << UPLOAD_URL << "\n";
    log << "Session started: " << timestamp() << "\n";
    if (dry_run) {
        log << "(Dry-run mode â€” uploads skipped)\n";
    }
    log << "\n";

    Stats stats;

    // Upload all files recursively (skip log file itself for now)
    for (const auto& entry : fs::recursive_directory_iterator(fs::current_path())) {
        if (fs::is_regular_file(entry.status()) && entry.path().filename() != LOG_FILENAME) {
            upload_file(entry.path().string(), log, &stats, dry_run);
        }
    }

    // Finish log session
    log << "\nSession ended: " << timestamp() << "\n";
    log << "Summary: " << stats.total << " attempted, "
        << stats.ok << " succeeded, "
        << stats.fail << " failed.\n";
    log << "=== End of log ===\n";
    log.close();

    // Upload the log itself
    Stats dummy_stats;
    if (!dry_run) {
        std::cout << "Uploading " << LOG_FILENAME << "...\n";
        std::ofstream dummy("upload_status.txt");
        upload_file(LOG_FILENAME, dummy, &dummy_stats, dry_run);
    } else {
        dummy_stats.ok = 1; // Pretend success
    }

    // Reopen log and append result of log upload with marker
    std::ofstream log_append(LOG_FILENAME, std::ios::app);
    log_append << "\n=== LOG UPLOAD RESULT ===\n";
    if (dry_run) {
        log_append << "[" << timestamp() << "] [SKIP] "
        << LOG_FILENAME << " (dry-run)\n";
    } else if (dummy_stats.ok > 0) {
        log_append << "[" << timestamp() << "] [OK]   "
        << LOG_FILENAME << " uploaded successfully.\n";
    } else {
        log_append << "[" << timestamp() << "] [FAIL] "
        << LOG_FILENAME << " upload failed after "
        << MAX_RETRIES << " attempts.\n";
    }
    log_append << "=== END LOG UPLOAD RESULT ===\n";
    log_append.close();

    if (!dry_run) {
        curl_global_cleanup();
    }

    // Exit codes:
    // 0 = everything succeeded
    // 1 = one or more file uploads failed
    // 2 = log upload failed
    if (dry_run) {
        return 0; // Dry-run always "succeeds"
    } else if (dummy_stats.ok == 0) {
        return 2; // log didnâ€™t make it
    } else if (stats.fail > 0) {
        return 1; // some files failed
    } else {
        return 0; // perfect run
    }
}
